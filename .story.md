---
focus: lib/states/counter.dart:18
---

### MVI & Clean Code: Rendering Logic of State in Flutter : Riverpod story : Create Counter model and notifier.


In order to separate the state and logic from the view, you need to store it somewhere.
A model class represents the state of some part of your application. In our case, it will display the state of the counter. 
We will use this class to store and display the current counter value in the middle of the screen.

Let's go through [CounterModel](lib/states/counter.dart:18). This object is only a wrapper for an integer. In fact, we can just use the integer directly. 
However, in this case, we will go the other way. Note that count is final. This means that the state is unchanged.
An alternative approach can be found in the Riverpod demo.
IMHO immutable state is good. I suggest you read "The drawbacks of coupling and mutability" article from recomendation to understand why. Firstly we change it value in one manner. Every time the state changes, we create a completely new CounterModel object. 
This might seem like extra work, but it prevents some of the subtle bugs that can arise from changing the internal values ​​of mutable state.
There is also a const constructor which, in addition to enforcing immutability, also allows you to declare compile-time optimized constants, a good read on this topic here.
We have created a Counter Model class to represent the state of a counter.
We now also need a class for managing the state, in particular for storing its current value and incrementing it when the user presses the FAB (+) button.

Let's go through [CounterNotifier](lib/states/counter.dart:5). It extends the StateNotifier state management class. StateNotifier is similar to Flutter's default ValueNotifier, or even Cubit from the Bloc package without underlying threads. 
This type of immutable state management is perfect for our task, and in the future I prefer to use it, plus immutable state, to prevent unpleasant surprises.
The State Notifier under the hood has a single internal variable named state that contains the current state, in our case a [CounterModel instance](lib/states/counter.dart:5). We can change the value of state, but the CounterModel is unchanged. That is, to change CounterModel.count we need to create a new object.
I need to initialize state, we will do this by passing the initial value of super to the constructor. Our code above initializes counter to 0.
The [increment](lib/states/counter.dart:12) function can be called externally, which replaces state with a new CountModel instance, 
whose internal count value is one greater than the last CountModel instance.
When the state changes, the StateNotifier notifies any objects that are listening to it.