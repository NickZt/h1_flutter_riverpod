---
focus: lib/main.dart:13
---

### MVI & Clean Code: Rendering Logic of State in Flutter : Riverpod story : Make it run.


Now is the time to make our application work. For the Riverpod magic to work, you need to wrap the entire  application with a widget [ProviderScope](lib/main.dart:13).

Now we create a global provider [_counterProvider](lib/main.dart:6)

Since [_counterProvider](lib/main.dart:6) is a global constant, we can access it from anywhere (without the need for an assembly context like Provider did if you've tried it). You usually hear in programming that you shouldn't use global variables. One reason is that it's easy to get subtle errors if different parts of your code change a variable. However, this global variable is immutable, so there is no danger of changing it. Another reason to be careful with globals (and constants) is to create dependency problems.
Riverpod has many different providers. In this example, we are using the StateNotifierProvider because the state is in the StateNotifier class ([CounterNotifier](lib/states/counter.dart:5)).
MyHomePage is currently the inheritor of StatelessWidget. Change StatelessWidget to ConsumerWidget to get a ref object. This object allows us to interact with providers, be it a widget or another provider.
Every time the counter value changes, it would be a good idea to display this in the user interface. To do this, we need to learn how to observe changes.
Simple add the following line inside the build method of MyHomePage (just before the return statement):
[final counter = ref.watch (_counterProvider) .count;](lib/main.dart:47) 

watch method will listen for changes to [_counterProvider](lib/main.dart:6).state, which is an instance of CounterModel. And accordingly we can access the .count field
in which CounterModel stores the counter value.
To display the counter state, let's change the [Text widget](lib/main.dart:50).


Counter update. When the user clicks the (+) button, we need to call the [.increment()](lib/states/counter.dart:12) method in our counter state management class ([CounterNotifier](lib/states/counter.dart:5)).

Replace the [onPressed](lib/main.dart:60) callback in the [FloatingActionButton](lib/main.dart:60) with the following bv:

'''

onPressed: () => ref.read ([_counterProvider](lib/main.dart:6).notifier) [.increment()](lib/states/counter.dart:12),

'''


The ref object has a read method. Unlike watch, the read method gives you a reference to your state management class
 ([CounterNotifier](lib/states/counter.dart:5)) ​​without tracking changes in state. The reason this is important is that the watch behind the 
 [CounterNotifier](lib/states/counter.dart:5) will cause the widget's build method to re-run when the state changes. If the widget, in this 
 case FAB ([FloatingActionButton](lib/main.dart:60)), does not visually change in any way, then it is useless to redraw it. 
 However, the current build method already in use will be called because there is a watch call inside the widget.
 This means that all widgets in this build method (including the [FAB](lib/main.dart:60)) will still be rebuilt. We'll optimize this later. 
 
 
 
 Let's try to launch the application, and the counter starts responding to clicks.


